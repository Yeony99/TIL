# 2021년 06월에 읽은 책

## 한 권으로 읽는 컴퓨터 구조와 프로그래밍
> 원제 : The Secret Life of Programs: Understand Computers -- Craft Better Code
> 조너선 스타인하트 지음
>> 컴퓨터 공학에 대한 기본적인 지식이 부족한 것 같아 가볍게 읽기 시작 (2021.06.14 ~)   

### 1장. 컴퓨터 내부의 언어 체계
#### 1. Boolean 대수
- NOT : 논리적 반대. NOT true = false, NOT false = true
- AND : 둘 이상 비트에 작용. 두 개의 비트가 모두 true 일 때에만 참
- OR : 둘 이상 비트에 작용. 두 개의 비트 중 하나가 true이면 참
- XOR : exclusive OR (배타적 OR). 두 개의 비트가 서로 다른 값일 경우에만 참.
  - T XOR T = false, T XOR F = true, F XOR T = true, F XOR F = false
#### 2. 드모르간의 법칙 (De Morgan's law)
- Boolean 대수에 적용할 수 있는 법칙
- a AND b 는 NOT(NOT a OR NOT b)와 같다
- 정논리와 부논리
  - 정논리에서는 OR 연산으로 `a(F) OR b(F) => F`, `a(F) OR b(T) => T`, ...가 된다.
  - 부논리에서는 드모르간의 법칙을 이용한 AND 연산으로 `NOT a(F) AND NOT b(F) => NOT F`, `NOT a(F) AND NOT b(T) -> NOT F` 가 된다. 
  - 부논리를 드모르간 법칙이 아닌 다른 방법으로 표현하려면, `NOT NOT a(F) OR NOT NOT b(T) -> F`로 표현해야 한다. (이것은 `NOT(NOT a OR NOT b)`와 같다.)
  
#### 3. 정수를 비트로 표현하는 방법
- 10진수의 숫자 개수는 표현할 수 있는 값의 범위를 결정한다.
- 유효비트
  - 2진수의 값이 가장 크게 변하냐, 작게 변하냐에 따른 구분.
  - 2진수의 가장 오른쪽 비트 : **가장 작은 유효 비트** (LSB, least significant bit)
  - 2진수의 가장 왼쪽 비트 : **가장 큰 유효 비트** (MSB, most significant bit)
- 2진수 덧셈
```
    1   0 0 1
    5   1 0 1
    -----------    
    6   1 1 0
```
- 컴퓨터의 2진수 덧셈
```
A   B   A AND B     A + B   A XOR B     A   B
----------------------------------------------
0   0       0         00       0        0   0
0   1       0         01       1        0   1
1   0       0         10       1        1   0
1   1       1         11       0        1   1
```

- 음수
    - 부호와 크기 표현법
      - MSB(가장 왼쪽 비트)에 부호를 표시한다.
      - MSB에 0이 위치하면 양수, 1이 위치하면 음수
      - 0부터의 거리(절댓값)을 표현하기 위해 사용하는 방법
    - 1의 보수(one's complement)
      - 양수의 모든 비트를 **뒤집어** 음수를 만드는 방법
      - 비트를 부호비트, 나머지로 나눈다.
      - NOT 연산을 통해 보수를 얻는다.
      - `0100`은 양수 2진수로, `4`이다. MSB를 먼저 1로 바꾼 후(`1111`, -0과 같다. ) -> 나머지 비트도 모두 반전시킨다.(`1011`, -4이다.)
      - 1의 보수 표현법의 문제는 양수도 음수도 아닌 0을 `0000 (+0)`과 `1111 (-0)`으로 표현하게 된다는 문제가 있다.
    - 2의 보수(two's complement)
      - 1의 보수또한 덧셈 등의 계산이 복잡하다. 현재 컴퓨터는 비용이 더 드는 부호와 크기 표현법, 1의 보수 표현법을 사용하지 않는다.
      - 2의 보수 표현법은 **부호가 있는 정수**를 표현할 때 가장 널리 쓰이는 방법.
      - 어떤 수의 비트를 뒤집고(각 비트의 NOT을 취하고) 1을 추가하면 음수를 얻는다. 
      - +1 : `0001`
      - -1 : `1111`
      - +2 : `0010` -> -2 : `1101` (뒤집고) -> `1110` (1 더하기) => -2 

#### 4. 실수를 비트로 표현하는 방법
- 고정소수점 표현 (fixed-point)
  - 소수점의 위치가 항상 일정하기 때문에 고정소수점이다.
  - 실수 `1.5`를 표현한다면, 4비트를 정수부와 분수부로 나누어 표현한다.
  - `00.10`은 1.5를 나타낸다. 4비트 중 2비트는 정수부, 나머지 2비트는 2진 소수점의 오른쪽에 있는 분수를 표현하는데 사용한다.
  - 소수점 뒤가 `00` -> `0`, `01` -> 1/4, `10` -> 2/4(1/2), `11` -> 3/4
  - 플랑크 상수나 아보가드로 수 같이 비트가 많이 소모되는 범위의 값을 나타내기 어렵다.

- 부동소수점 표현 (floating-point)
  - 과학적 표기법을 2진수에 적용한 표현법이다. (거듭제곱을 표현하는 지수)
  - 0.0012 -> `1.2 * 10­－³ (10의 -3제곱)`
  - 소수점 앞은 가수부, 소수점 뒤는 지수부이다.
  - 비트 조합 중에 낭비되는 부분이 많다. 
  - 비트 패턴이 가능한 모든 수를 표현하지 못한다.
- IEEE 부동소수점 수 표현
  - 부동소수점 표현에서 낭비되는 비트 조합을 최소화하기 위해 도출된 방법
  - 정밀도(single precision) 부동소수점 수 (32비트 사용)
  - 2배 정밀도(double precision) 부동소수점 수 (64비트 사용)

#### 5. 2진수를 다루는 쉬운 방법
- 8진 표현법
  - 2진수 비트들을 3개씩 그룹화
  - `10 0101 1100 0101 0100`라는 2진수 비트가 있을 때, 이를 8진 표현법으로 바꾼다
  - `100 101 110 001 010 100`이라는 8진 표현법은, `100 => 4`, `101 => 5` ...로 바꾸어 `456124`라는 값을 얻을 수 있다.
- 16진 표현법
  - 요즘 컴퓨터 내부는 8비트의 배수를 사용해 만들어지기 때문에 16진 표현법을 많이 사용한다.
  - ABCDEF 기호는 10부터 15까지의 숫자를 표현한다.
  - `1101 0011 1111 1100 0001`라는 2진수 비트를 16진 표현법으로 바꾼다.
  - ` D 3 F C 1 `이 위 2진수를 16진으로 표현한 결과이다.
- 표현법 구분
  - 0으로 시작하는 숫자는 8진수
  - 1~9로 시작하느 숫자는 10진수
  - 0x가 붙은 숫자는 16진수
